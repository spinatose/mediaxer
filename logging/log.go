package logging

import (
	"fmt"
	"os"
	"path"
	"strings"
	"time"

	"github.com/ik5/rotatefilehook"
	log "github.com/sirupsen/logrus"
	"spinatose.com/mediaxer/config"
)

// Philosophy for logging: Logging should be "nice to have" for this app, but
// should not hinder execution. Any errors should be caught and given as warnings
// if originally generated by the global logger. Eventually, will make logger 
// writes asynchronous to also limit impact on performance. 

type LogLevel int

const (
	Trace LogLevel = iota
	Debug
	Info
	Warn
	Error
	Fatal
	Panic
)

type Fields map[string]interface{}

type logger struct {
	logEntry *log.Entry
}

type Logger struct {
	LogLevel  LogLevel
	logWriter *logger
	metaData  Fields 
}

// Returns a logger constructed from supplied configuration. Only one of each type 
// of output is expected- "file" or "console".
// Logger outputs can have different logging levels that they will log for- for 
// example: console - info and above only, file - trace and above - or whatever is
// desired. 
func NewLogger(logConfig config.Logger, fields Fields) *Logger {
	// Set log level of log entry to Trace so that it would write everything, but actual LogLevel
	// will be controlled by Global Logger.
	log.SetLevel(log.TraceLevel)

	globalLogger := &Logger{
		LogLevel: parseLogLevel(logConfig.Level),
		logWriter: nil,
		metaData: fields,
	}

	// need to check for more than one of each output type
	consoleOutFound, fileOutFound := false, false 
	var fileConfig    config.LogOutput
	var consoleConfig config.LogOutput

	for _, lconfig := range logConfig.Outputs {
		// check output type before adding to global loggers
		outType := lconfig.LogType 
		outType = strings.ToLower(strings.Trim(outType, " "))

		if outType != "console" && outType != "file" {
			fmt.Printf("WARN: invalid output type for logger found in config [%s]- skipping output\n", outType)	
			continue 
		} else {
			if outType == "console" && !consoleOutFound {
				consoleOutFound = true 
			} else if outType == "console" && consoleOutFound {
				fmt.Println("WARN: an output type has already been found for 'console' out- skipping output")	
				continue 
			}

			if outType == "file" && !fileOutFound {
				fileConfig = lconfig 
				fileOutFound = true 
			} else if outType == "file" && fileOutFound {
				fmt.Println("WARN: an output type has already been found for 'file' out- skipping output")	
				continue 
			}
		}
		
	}

	// Set up file logger
	if fileOutFound {
		fileHook, err := setupFileLogger(fileConfig)
		
		if err != nil {
			fmt.Printf("Unable to setup file logger, skipping... error: %v\n", err)
		} else {
			log.AddHook(fileHook)
		}
	}

	// Set up console logger
	if consoleOutFound {
		log.SetOutput(os.Stdout)
		log.SetFormatter(&log.TextFormatter{
			ForceColors:     consoleConfig.Options.Colorize,
			FullTimestamp:   true,
			//TimestampFormat: time.RFC822,
		})
	}

	logEntry := log.WithFields(log.Fields(globalLogger.metaData))
	logger := &logger{
		logEntry: logEntry,
	}

	globalLogger.logWriter = logger

	return globalLogger
}

func MergeFieldMaps(firstFields, secondFields map[string]interface{}) map[string]interface{} {
	for k, v := range secondFields {
		firstFields[k] = v
	}
	return firstFields
}

func setupFileLogger(config config.LogOutput) (log.Hook, error) {
	// will have to test for backslash on path 
	return rotatefilehook.NewRotateFileHook(rotatefilehook.RotateFileConfig{
		Filename:   path.Join(config.Options.Config.Path, config.Options.Config.FileName),
		MaxSize:    50, // megabytes
		MaxBackups: 3,
		MaxAge:     28, //days
		Level: log.DebugLevel,
		Formatter: &log.JSONFormatter{
			TimestampFormat: time.RFC3339,
		},
	})
}

// Writes entries for loggers based on their log level setting and the 
// log level of the individual requested write entry. 
func (l *Logger) writeEntry(methodLogLevel LogLevel, args ...interface{}){
	if len(args) > 0 {
		var fields Fields = nil
		msg := args[0]

		if len(args) > 1 {
			fields =  Fields(args[1].(Fields))
		}

		var entry *log.Entry 

		if fields != nil {
			entry = l.logWriter.logEntry.WithFields(log.Fields(fields))
		} else {
			entry = l.logWriter.logEntry
		}

		if  l.LogLevel <= methodLogLevel {
			switch(methodLogLevel){
			case Trace:
				entry.Trace(msg)
			case Debug:
				entry.Debug(msg)
			case Info:
				entry.Info(msg)
			case Warn:
				entry.Warn(msg)
			case Error:
				entry.Error(msg)
			case Fatal:
				entry.Fatal(msg)
			case Panic:
				entry.Panic(msg)
			}
		}
	}
}

func (l *Logger) Trace(args ...interface{}) {
	l.writeEntry(Trace, args)
}

func (l *Logger) Debug(args ...interface{}) {
	l.writeEntry(Debug, args)
}

func (l *Logger) Info(args ...interface{}) {
	l.writeEntry(Info, args)
}

func (l *Logger) Warn(args ...interface{}) {
	l.writeEntry(Warn, args)
}

func (l *Logger) Error(args ...interface{}) {
	l.writeEntry(Error, args)
}

func (l *Logger) Fatal(args ...interface{}) {
	l.writeEntry(Fatal, args)
}

func (l *Logger) Panic(args ...interface{}) {
	l.writeEntry(Panic, args)
}

// Parses a string and determines if it mataches a log level designated
// for the global logger. 
// Returns INFO level by default.
func parseLogLevel(level string) LogLevel {
	level = strings.ToLower(strings.Trim(level, " "))

	switch level {
	case "trace":
		return Trace
	case "debug":
		return Debug
	case "info":
		return Info
	case "warn":
		return Warn
	case "error":
		return Error
	case "fatal":
		return Fatal
	case "panic":
		return Panic
	}

	return Info
}