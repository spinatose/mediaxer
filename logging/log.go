package logging

import (
	"fmt"
	"os"
	"path"
	"strings"
	"time"

	"github.com/ik5/rotatefilehook"
	log "github.com/sirupsen/logrus"
	"spinatose.com/mediaxer/config"
)

// Philosophy for logging: Logging should be "nice to have" for this app, but
// should not hinder execution. Any errors should be caught and given as warnings
// if originally generated by the global logger. Eventually, will make logger 
// writes asynchronous to also limit impact on performance. 

type LogLevel int

const (
	Trace LogLevel = iota
	Debug
	Info
	Warn
	Error
	Fatal
	Panic
)

var metaData map[string]interface{}

type logger struct {
	logEntry *log.Entry
	logLevel LogLevel
}

type Logger struct {
	loggers []*logger
}

// Returns a logger constructed from supplied configuration. Only one of each type 
// of output is expected- "file" or "console".
// Logger outputs can have different logging levels that they will log for- for 
// example: console - info and above only, file - trace and above - or whatever is
// desired. 
func NewLogger(configs []config.LogOutput) *Logger {
	metaData = log.Fields{	"application": "mediaxer" }

	// Set log level of log entry to Trace so that it would write everything, but actual LogLevel
	// will be controlled by Global Logger.
	log.SetLevel(log.TraceLevel)

	globalLogger := &Logger{
		loggers: nil,
	}

	// need to check for more than one of each output type
	consoleOutFound, fileOutFound := false, false 

	for i, lconfig := range configs {
		// check output type before adding to global loggers
		outType := lconfig.LogType 
		outType = strings.ToLower(strings.Trim(outType, " "))

		if outType != "console" && outType != "file" {
			fmt.Printf("WARN: invalid output type for logger found in config [%s]- skipping output\n", outType)	
			continue 
		} else {
			if outType == "console" && !consoleOutFound {
				consoleOutFound = true 
			} else if outType == "console" && consoleOutFound {
				fmt.Println("WARN: an output type has already been found for 'console' out- skipping output")	
				continue 
			}

			if outType == "file" && !fileOutFound {
				fileOutFound = true 
			} else if outType == "file" && fileOutFound {
				fmt.Println("WARN: an output type has already been found for 'file' out- skipping output")	
				continue 
			}
		}

		logFields := mergeFieldMaps(metaData, log.Fields{
			"level":       lconfig.Options.Level,
			"loggerId":    i,
			"output":      lconfig.LogType,
		})

		// Set up file logger
		if fileOutFound {
			fileHook, err := setupFileLogger(lconfig)
			
			if err != nil {
				fmt.Printf("Unable to setup file logger, skipping... error: %v\n", err)
				continue
			}

			log.AddHook(fileHook)
		}

		// Set up console logger
		if consoleOutFound {
			log.SetOutput(os.Stdout)
			log.SetFormatter(&log.TextFormatter{
				ForceColors:     lconfig.Options.Colorize,
				FullTimestamp:   true,
				//TimestampFormat: time.RFC822,
			})
		}

		logEntry := log.WithFields(logFields)

		// Temporarily set log output to terminal
		//logEntry.Logger.Out = os.Stdout

		logger := &logger{
			logEntry: logEntry,
			logLevel: parseLogLevel(lconfig.Options.Level),
		}

		globalLogger.loggers = append(globalLogger.loggers, logger)
	}

	return globalLogger
}

func mergeFieldMaps(firstFields, secondFields map[string]interface{}) map[string]interface{} {
	for k, v := range secondFields {
		firstFields[k] = v
	}
	return firstFields
}


func setupFileLogger(config config.LogOutput) (log.Hook, error) {
	// will have to test for backslash on path 
	return rotatefilehook.NewRotateFileHook(rotatefilehook.RotateFileConfig{
		Filename:   path.Join(config.Options.Config.Path, config.Options.Config.FileName),
		MaxSize:    50, // megabytes
		MaxBackups: 3,
		MaxAge:     28, //days
		Level: log.DebugLevel,
		Formatter: &log.JSONFormatter{
			TimestampFormat: time.RFC3339,
		},
	})
}

// Writes entries for loggers based on their log level setting and the 
// log level of the individual requested write entry. 
func (l *Logger) writeEntry(methodLogLevel LogLevel, args interface{}){
	for _, logger := range l.loggers {
		if logger.logLevel >= methodLogLevel {
			switch(methodLogLevel){
			case Trace:
				logger.logEntry.Trace(args)
			case Debug:
				logger.logEntry.Debug(args)
			case Info:
				logger.logEntry.Info(args)
			case Warn:
				logger.logEntry.Warn(args)
			case Error:
				logger.logEntry.Error(args)
			case Fatal:
				logger.logEntry.Fatal(args)
			case Panic:
				logger.logEntry.Panic(args)
			}
		}
	}
}

func (l *Logger) Trace(args interface{}) {
	l.writeEntry(Trace, args)
}

func (l *Logger) Debug(args interface{}) {
	l.writeEntry(Debug, args)
}

func (l *Logger) Info(args interface{}) {
	l.writeEntry(Info, args)
}

func (l *Logger) Warn(args interface{}) {
	l.writeEntry(Warn, args)
}

func (l *Logger) Error(args interface{}) {
	l.writeEntry(Error, args)
}

func (l *Logger) Fatal(args interface{}) {
	l.writeEntry(Fatal, args)
}

func (l *Logger) Panic(args interface{}) {
	l.writeEntry(Panic, args)
}

// Parses a string and determines if it mataches a log level designated
// for the global logger. 
// Returns INFO level by default.
func parseLogLevel(level string) LogLevel {
	level = strings.ToLower(strings.Trim(level, " "))

	switch level {
	case "trace":
		return Trace
	case "debug":
		return Debug
	case "info":
		return Info
	case "warn":
		return Warn
	case "error":
		return Error
	case "fatal":
		return Fatal
	case "panic":
		return Panic
	}

	return Info
}

/*  snippet for logging to more than one output with different loglevels
    I will limit to only one console output	and one file output

	var logLevel = logrus.InfoLevel
	if debug {
		logLevel = logrus.DebugLevel
	}

	rotateFileHook, err := rotatefilehook.NewRotateFileHook(rotatefilehook.RotateFileConfig{
		Filename:   "logs/console.log",
		MaxSize:    50, // megabytes
		MaxBackups: 3,
		MaxAge:     28, //days
		Level:      logLevel,
		Formatter: &logrus.JSONFormatter{
			TimestampFormat: time.RFC822,
		},
	})

	if err != nil {
		logrus.Fatalf("Failed to initialize file rotate hook: %v", err)
	}

	logrus.SetLevel(logLevel)
	logrus.SetOutput(colorable.NewColorableStdout())
	logrus.SetFormatter(&logrus.TextFormatter{
		ForceColors:     true,
		FullTimestamp:   true,
		TimestampFormat: time.RFC822,
	})
	logrus.AddHook(rotateFileHook)
*/

/* snippet for using lumberjack to rotate a log file with different pruning mgmt

import (
  "github.com/ik5/rotatefilehook"
)

rotateFileHook, err := rotatefilehook.NewRotateFileHook(rotatefilehook.RotateFileConfig{
    Filename: "logfile.log",
    MaxSize: 5,
    MaxBackups: 7,
    MaxAge: 7,
    Level: logrus.LevelDebug,
    Formatter: logrus.TextFormatter,
})
if err != nil {
  panic(err)
}

log.Hooks.Add(rotateFileHook)

err = rotateFileHook.Rotate() // To force rotation
if err != nil {
  panic(err)
}

*/